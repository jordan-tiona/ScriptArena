"'use strict';\n\n/* eslint-disable no-restricted-globals */\n\n// This file subclasses and stores the JS builtins that come from the VM\n// so that Node.js's builtin modules do not need to later look these up from\n// the global proxy, which can be mutated by users.\n\n// TODO(joyeecheung): we can restrict access to these globals in builtin\n// modules through the JS linter, for example: ban access such as `Object`\n// (which falls back to a lookup in the global proxy) in favor of\n// `primordials.Object` where `primordials` is a lexical variable passed\n// by the native module compiler.\n\nconst ReflectApply = Reflect.apply;\n\n// This function is borrowed from the function with the same name on V8 Extras'\n// `utils` object. V8 implements Reflect.apply very efficiently in conjunction\n// with the spread syntax, such that no additional special case is needed for\n// function calls w/o arguments.\n// Refs: https://github.com/v8/v8/blob/d6ead37d265d7215cf9c5f768f279e21bd170212/src/js/prologue.js#L152-L156\nfunction uncurryThis(func) {\n  return (thisArg, ...args) => ReflectApply(func, thisArg, args);\n}\n\nprimordials.uncurryThis = uncurryThis;\n\nfunction copyProps(src, dest) {\n  for (const key of Reflect.ownKeys(src)) {\n    if (!Reflect.getOwnPropertyDescriptor(dest, key)) {\n      Reflect.defineProperty(\n        dest,\n        key,\n        Reflect.getOwnPropertyDescriptor(src, key));\n    }\n  }\n}\n\nfunction copyPropsRenamed(src, dest, prefix) {\n  for (const key of Reflect.ownKeys(src)) {\n    if (typeof key === 'string') {\n      Reflect.defineProperty(\n        dest,\n        `${prefix}${key[0].toUpperCase()}${key.slice(1)}`,\n        Reflect.getOwnPropertyDescriptor(src, key));\n    }\n  }\n}\n\nfunction copyPropsRenamedBound(src, dest, prefix) {\n  for (const key of Reflect.ownKeys(src)) {\n    if (typeof key === 'string') {\n      const desc = Reflect.getOwnPropertyDescriptor(src, key);\n      if (typeof desc.value === 'function') {\n        desc.value = desc.value.bind(src);\n      }\n      Reflect.defineProperty(\n        dest,\n        `${prefix}${key[0].toUpperCase()}${key.slice(1)}`,\n        desc\n      );\n    }\n  }\n}\n\nfunction copyPrototype(src, dest, prefix) {\n  for (const key of Reflect.ownKeys(src)) {\n    if (typeof key === 'string') {\n      const desc = Reflect.getOwnPropertyDescriptor(src, key);\n      if (typeof desc.value === 'function') {\n        desc.value = uncurryThis(desc.value);\n      }\n      Reflect.defineProperty(\n        dest,\n        `${prefix}${key[0].toUpperCase()}${key.slice(1)}`,\n        desc);\n    }\n  }\n}\n\nfunction makeSafe(unsafe, safe) {\n  copyProps(unsafe.prototype, safe.prototype);\n  copyProps(unsafe, safe);\n  Object.setPrototypeOf(safe.prototype, null);\n  Object.freeze(safe.prototype);\n  Object.freeze(safe);\n  return safe;\n}\n\n// Subclass the constructors because we need to use their prototype\n// methods later.\nprimordials.SafeMap = makeSafe(\n  Map,\n  class SafeMap extends Map {}\n);\nprimordials.SafeWeakMap = makeSafe(\n  WeakMap,\n  class SafeWeakMap extends WeakMap {}\n);\nprimordials.SafeSet = makeSafe(\n  Set,\n  class SafeSet extends Set {}\n);\nprimordials.SafePromise = makeSafe(\n  Promise,\n  class SafePromise extends Promise {}\n);\n\n// Create copies of the namespace objects\n[\n  'JSON',\n  'Math',\n  'Reflect'\n].forEach((name) => {\n  copyPropsRenamed(global[name], primordials, name);\n});\n\n// Create copies of intrinsic objects\n[\n  'Array',\n  'ArrayBuffer',\n  'BigInt',\n  'BigInt64Array',\n  'BigUint64Array',\n  'Boolean',\n  'Date',\n  'Error',\n  'Float32Array',\n  'Float64Array',\n  'Function',\n  'Int16Array',\n  'Int32Array',\n  'Int8Array',\n  'Map',\n  'Number',\n  'Object',\n  'RegExp',\n  'Set',\n  'String',\n  'Symbol',\n  'Uint16Array',\n  'Uint32Array',\n  'Uint8Array',\n  'Uint8ClampedArray',\n  'WeakMap',\n  'WeakSet',\n].forEach((name) => {\n  const original = global[name];\n  primordials[name] = original;\n  copyPropsRenamed(original, primordials, name);\n  copyPrototype(original.prototype, primordials, `${name}Prototype`);\n});\n\n// Create copies of intrinsic objects that require a valid `this` to call\n// static methods.\n// Refs: https://www.ecma-international.org/ecma-262/#sec-promise.all\n[\n  'Promise',\n].forEach((name) => {\n  const original = global[name];\n  primordials[name] = original;\n  copyPropsRenamedBound(original, primordials, name);\n  copyPrototype(original.prototype, primordials, `${name}Prototype`);\n});\n\nObject.setPrototypeOf(primordials, null);\nObject.freeze(primordials);\n"
